cat("second kind of the plots seen before")
plot(mcmc_lognorm_cens)
knitr::opts_chunk$set(echo = TRUE)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("helpfunctions.r")
library("runjags")
library("coda")
library("rjags")
library("survival")
source("Bayes1_Weibull_jags.R")
source("Bayes1_Weibull_cens_jags.R")
#coda integration so also coda stuff is available
#Model Diagnostik plots
summary(weibull_cens_mcmc)
summary(weibull_cens)
#coda integration so also coda stuff is available
#Model Diagnostik plots
weibull_cens_mcmc <- as.mcmc.list(weibull)
print("gelman diag")
gelman.diag(weibull_cens_mcmc, confidence = 0.95)
gelman.plot(weibull_cens_mcmc, confidence = 0.95)
print("geweke diag")
geweke.diag(weibull_cens_mcmc)
geweke.plot(weibull_cens_mcmc)
subset_pred <- grepl("Deviance", dimnames(weibull_cens_rep_mcmc[[1]])[[2]])
mcmc_subset <- get_values(weibull_cens_rep_mcmc,subset_pred)
md <- mean(mcmc_subset)
a <- summary(lognorm_cens_rep)
subset_pred <- grepl("Deviance", dimnames(weibull_cens_rep_mcmc[[1]])[[2]])
mcmc_subset <- get_values(weibull_cens_rep_mcmc,subset_pred)
md <- mean(mcmc_subset)
a <- summary(weibull_cens_rep_mcmc)
a1 <- a[c("beta0","beta1","beta2","scale"),"Mean"]
a
a[c("beta0","beta1","beta2","scale"),"Mean"]
a[c("beta0","beta1","beta2"),"Mean"]
a[,"Mean"]
as.matrix(a)
as.matrix(a)
a
a[1,1]
View(a)
a$statistics
a1 <- a$statistics[c("beta0","beta1","beta2","scale"),"Mean"]
a1
subset_pred <- grepl("Deviance", dimnames(weibull_cens_rep_mcmc[[1]])[[2]])
mcmc_subset <- get_values(weibull_cens_rep_mcmc,subset_pred)
md <- mean(mcmc_subset)
a <- summary(weibull_cens_rep_mcmc)
a1 <- a$statistics[c("beta0","beta1","beta2","scale"),"Mean"]
#there is no real y value therefore again use the simulated ones
subset_pred <- grepl("y\\[", dimnames(weibull_cens_rep_mcmc[[1]])[[2]])
mcmc_subset <- get_values(weibull_cens_rep_mcmc,subset_pred)
subset_pred
source("Bayes1_Weibull_cens_jags.R")
subset_pred <- grepl("Deviance", dimnames(weibull_cens_rep_mcmc[[1]])[[2]])
mcmc_subset <- get_values(weibull_cens_rep_mcmc,subset_pred)
md <- mean(mcmc_subset)
a <- summary(weibull_cens_rep_mcmc)
a1 <- a$statistics[c("beta0","beta1","beta2","scale"),"Mean"]
#there is no real y value therefore again use the simulated ones
subset_pred <- grepl("y\\[", dimnames(weibull_cens_rep_mcmc[[1]])[[2]])
mcmc_subset <- get_values(weibull_cens_rep_mcmc,subset_pred)
Grub$sim_value <- apply(mcmc_subset,2,mean)
#now we cann use this values for comparison
scale <- exp(a1["beta0"]+a1["beta1"]*Grub$grubsize + a1["beta2"]*Grub$group)
#for exampe see weibull_baysian_easy (i know wrong spelling ^^) exp()
shape <- 1/a1["scale"]
pd <- md - -2*sum(dweibull(Grub$sim_value, scale = scale, shape  = shape, log = T))
c(pd,md,pd+md)
a <- summary(weibull_rep)
a1 <- a[c("beta0","beta1","beta2","scale"),"Mean"]
subset_pred <- grepl("ppo\\[", dimnames(weibull_mcmc_rep[[1]])[[2]])
mcmc_subset <- get_values(weibull_mcmc_rep,subset_pred)
#ppo which are now far of?
plot(1/apply(as.matrix(mcmc_subset),2,mean))
plot(weibull_cens)
#The DIC Value for model comparison
cat("second kind of the plots seen before")
plot(weibull_cens_mcmc)
source("Bayes1_lognormal_cens_Random_jags.R")
#coda integration so also coda stuff is available
#Model Diagnostik plots
lognorm_rand_cens_mcmc <- as.mcmc.list(lognorm_rand_cens)
summary(lognorm_rand_cens_mcmc)
summary(lognorm_rand_cens)
print("gelman diag")
gelman.diag(lognorm_rand_cens_mcmc, confidence = 0.95)
gelman.plot(lognorm_rand_cens_mcmc, confidence = 0.95)
print("geweke diag")
geweke.diag(lognorm_rand_cens_mcmc)
geweke.plot(lognorm_rand_cens_mcmc)
subset_pred <- grepl("ppo\\[", dimnames(lognorm_rand_cens_mcmc_rep[[1]])[[2]])
mcmc_subset <- get_values(lognorm_rand_cens_mcmc_rep,subset_pred)
#ppo which are now far of?
plot(1/apply(as.matrix(mcmc_subset),2,mean))
#2.) extract the res values
subset_pred <- grepl("res\\[", dimnames(lognorm_rand_cens_mcmc_rep[[1]])[[2]])
mcmc_subset <- get_values(lognorm_rand_cens_mcmc_rep,subset_pred)
subset_pred
subset_pred <- grepl("ppo\\[", dimnames(lognorm_rand_cens_mcmc_rep[[1]])[[2]])
mcmc_subset <- get_values(lognorm_rand_cens_mcmc_rep,subset_pred)
#ppo which are now far of?
plot(1/apply(as.matrix(mcmc_subset),2,mean))
plot(lognorm_rand_cens)
print(lognorm_rand_cens)
#The DIC Value for model comparison
cat("second kind of the plots seen before")
plot(lognorm_rand_cens_mcmc)
source("Bayes1_Weibull_cens_Random_jags.R")
source("Bayes1_Weibull_cens_Random_jags.R")
source("Bayes1_Weibull_cens_Random_jags.R")
#coda integration so also coda stuff is available
#Model Diagnostik plots
weibull_cens_rand_mcmc <- as.mcmc.list(weibull_cens_rand)
summary(weibull_cens_rand_mcmc)
summary(weibull_cens_rand)
subset_pred <- grepl("ppo\\[", dimnames(weibull_cens_rand_mcmc_rep[[1]])[[2]])
mcmc_subset <- get_values(weibull_cens_rand_mcmc_rep,subset_pred)
#ppo which are now far of?
plot(1/apply(as.matrix(mcmc_subset),2,mean))
plot(weibull_cens_rand)
#The DIC Value for model comparison
cat("second kind of the plots seen before")
plot(weibull_cens_rand_mcmc)
summary_weibull <- summary(weibull_cens_rand_mcmc_rep)
b_params <- summary_weibull$statistics[grepl("b0\\[", dimnames(summary_weibull$statistics)[[1]]),]
#mean(b_params[1:10,1])
#attributes(summary_weibull$statistics)
#how unnormal the random effects
mean(get_values(weibull_cens_rand_mcmc_rep,"tmax.test"))
mean(get_values(weibull_cens_rand_mcmc_rep,"tmin.test"))
mean(get_values(weibull_cens_rand_mcmc_rep,"ks.test"))
knitr::opts_chunk$set(echo = TRUE)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("helpfunctions.r")
library("runjags")
library("coda")
library("rjags")
library("survival")
source("Bayes1_Weibull_Random_jags.R")
knitr::opts_chunk$set(echo = TRUE)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("helpfunctions.r")
library("runjags")
library("coda")
library("rjags")
library("survival")
source("Bayes1_Weibull_Random_jags.R")
source("Bayes1_Weibull_Random_jags.R")
summary_weibull <- summary(weibull_rand_mcmc_rep)
b_params <- summary_weibull$statistics[grepl("res\\[", dimnames(summary_weibull$statistics)[[1]]),]
hist(apply(b_params,2,mean))
#mean(b_params[1:10,1])
#attributes(summary_weibull$statistics)
#how unnormal the random effects
mean(get_values(weibull_rand_mcmc_rep,"tmax.test"))
mean(get_values(weibull_rand_mcmc_rep,"tmin.test"))
mean(get_values(weibull_rand_mcmc_rep,"ks.test"))
View(b_params)
hist(b_params[,"Mean"])
hist(b_params[,"Mean"],breaks = 20)
hist(b_params[,"Mean"],breaks = 50)
knitr::opts_chunk$set(echo = TRUE)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("helpfunctions.r")
library("runjags")
library("coda")
library("rjags")
library("survival")
source("Bayes1_Weibull_Random_jags.R")
summary_weibull <- summary(weibull_rand_mcmc_rep)
b_params <- summary_weibull$statistics[grepl("res\\[", dimnames(summary_weibull$statistics)[[1]]),]
hist(b_params[,"Mean"],breaks = 50)
#mean(b_params[1:10,1])
#attributes(summary_weibull$statistics)
#how unnormal the random effects
mean(get_values(weibull_rand_mcmc_rep,"tmax.test"))
mean(get_values(weibull_rand_mcmc_rep,"tmin.test"))
mean(get_values(weibull_rand_mcmc_rep,"ks.test"))
mean(get_values(weibull_rand_mcmc_rep,"ss.test"))
# summary_weibull <- summary(weibull_rand_mcmc_rep)
# b_params <- summary_weibull$statistics[grepl("res\\[", dimnames(summary_weibull$statistics)[[1]]),]
# hist(b_params[,"Mean"],breaks = 50)
#mean(b_params[1:10,1])
#attributes(summary_weibull$statistics)
#how unnormal the random effects
mean(get_values(weibull_rand_mcmc_rep,"tmax.test"))
mean(get_values(weibull_rand_mcmc_rep,"tmin.test"))
mean(get_values(weibull_rand_mcmc_rep,"ks.test"))
mean(get_values(weibull_rand_mcmc_rep,"ss.test"))
subset_pred <- grepl("b0\\[", dimnames(lognorm_rand_mcmc_rep[[1]])[[2]])
# summary_weibull <- summary(weibull_rand_mcmc_rep)
# b_params <- summary_weibull$statistics[grepl("res\\[", dimnames(summary_weibull$statistics)[[1]]),]
# hist(b_params[,"Mean"],breaks = 50)
#mean(b_params[1:10,1])
#attributes(summary_weibull$statistics)
#how unnormal the random effects
mean(get_values(weibull_rand_mcmc_rep,"tmax.test"))
mean(get_values(weibull_rand_mcmc_rep,"tmin.test"))
mean(get_values(weibull_rand_mcmc_rep,"ks.test"))
mean(get_values(weibull_rand_mcmc_rep,"ss.test"))
subset_pred <- grepl("b0\\[", dimnames(weibull_rand_mcmc_rep[[1]])[[2]])
mcmc_subset <- get_values(weibull_rand_mcmc_rep,subset_pred)
#ppo which are now far of?
plot((as.matrix(mcmc_subset),2,mean))
#ppo which are now far of?
plot(apply(as.matrix(mcmc_subset),2,mean))
#ppo which are now far of?
hist(apply(as.matrix(mcmc_subset),2,mean))
hist(apply(as.matrix(mcmc_subset),2,mean), breaks = 20)
hist(apply(as.matrix(mcmc_subset),2,mean), breaks = 5)
hist(apply(as.matrix(mcmc_subset),2,mean), breaks = 9)
hist(apply(as.matrix(mcmc_subset),2,mean), breaks = 10)
apply(as.matrix(mcmc_subset),2,mean)
summary(apply(as.matrix(mcmc_subset),2,mean))
(apply(as.matrix(mcmc_subset),2,mean))
hist(mcmc_subset)
hist(mcmc_subset, breaks = 20)
source("Bayes1_lognormal_jags.R")
subset_pred <- grepl("y_rep\\[", dimnames(lognormal_mcmc_rep[[1]])[[2]])
mcmc_subset <- get_values(lognormal_mcmc_rep,subset_pred)
mcmc_subset
Grub$value
t(mcmc_subset)
mcmc_subset
apply(mcmc_subset,1,function(x){x > Grub$value})
apply(apply(mcmc_subset,1,function(x){x > Grub$value}),2,mean)
min(apply(apply(mcmc_subset,1,function(x){x > Grub$value}),2,mean))
max(apply(apply(mcmc_subset,1,function(x){x > Grub$value}),2,mean))
max(apply(apply(mcmc_subset,1,function(x){x > Grub$value}),2,mean))
max(apply(apply(mcmc_subset,1,function(x){x > Grub$value}),2,mean))
mcmc_subset[1,]
mcmc_subset[,1]
summary(mcmc_subset[,1])
source("Bayes1_lognormal_jags.R")
max(apply(apply(mcmc_subset,1,function(x){x > Grub$value}),2,mean))
subset_pred <- grepl("y_rep\\[", dimnames(lognormal_mcmc_rep[[1]])[[2]])
mcmc_subset <- get_values(lognormal_mcmc_rep,subset_pred)
Grub$value
mcmc_subset
#how often are the values bigger or smallen than the predicted ones
max(apply(apply(mcmc_subset,1,function(x){x > Grub$value}),2,mean))
summary(mcmc_subset[,1])
subset_pred <- grepl("y_rep\\[", dimnames(lognormal_mcmc_rep[[1]])[[2]])
mcmc_subset <- get_values(lognormal_mcmc_rep,subset_pred)
# Grub$value
# mcmc_subset
#how often are the values bigger or smallen than the predicted ones
max(apply(apply(mcmc_subset,1,function(x){x > Grub$value}),2,mean))
summary(mcmc_subset[,1])
hist(Grub$value)
hist(mcmc_subset[1,])
hist(Grub$value)
hist(mcmc_subset[1,])
hist(mcmc_subset[1,],bins = 20)
hist(mcmc_subset[1,],breaks = 20)
hist(mcmc_subset[2,],breaks = 20)
hist(mcmc_subset[3,],breaks = 20)
hist(mcmc_subset[1,],breaks = 20)
hist(mcmc_subset[3,],breaks = 20)
hist(Grub$value)
hist(mcmc_subset[3,],breaks = 20)
mean(mcmc_subset)
mean(Grub$value)
plot(Grub$value, Grub$grubsize)
plot(Grub$grubsize, Grub$alue)
plot(Grub$grubsize, Grub$value)
knitr::opts_chunk$set(echo = TRUE)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("helpfunctions.r")
library("runjags")
library("coda")
library("rjags")
library("survival")
plot(survfit(Surv(value) ~ 1, data = Grub),
xlab = "Days",
ylab = "Overall survival probability",conf.int = F,col = 2)
plot(survfit(Surv(value) ~ group, data = Grub),
xlab = "Days",
ylab = "Overall survival probability per group",conf.int = F,col = c(1,2))
knitr::opts_chunk$set(echo = TRUE)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#helpfunctions is just used but getvalues() i think
source("helpfunctions.r")
library("runjags")
library("coda")
library("rjags")
library("survival")
source("Bayes1_lognormal_jags.R")
#Bayes1_lognormal_random.r
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library("runjags")
library("coda")
library("rjags")
Grub <- read.csv("..\\data\\Grubs_Easy.csv")
Grub$grubsize  <-  Grub$grubsize - mean(Grub$grubsize)
# model.inits <-list(list(sigma=2, beta0=1, beta1 = 1,beta2 = 1, b0 = c(rep(1,times = 20))),
#                    list(sigma=2, beta0=1, beta1 = 1,beta2 = 1, b0 = c(rep(1,times = 20))))
model.inits <-list(list(sigma=2, beta1 = 1, b0 = c(rep(1,times = 20))),
list(sigma=2, beta1 = 1, b0 = c(rep(1,times = 20))))
parameters = c("sigma", "beta2", "beta1","sigma_b0")
model.data <- list( y = Grub$value, N = length(Grub$value), x1 = Grub$grubsize,
id = Grub$id,x2 = Grub$group,  Nsubj = length(unique(Grub$id)))
model.function <- "model{
for (i in 1:N){
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]+ b0[id[i]]
}
#priors
sigma ~ dgamma(0.001,0.001)
tau_b0 <- 1/sigma_b0
sigma_b0 ~ dunif(0,100)
beta0 ~ dnorm(0,0.000001)
beta1 ~ dnorm(0,0.000001)
beta2 ~ dnorm(0,0.000001)
for ( i in 1:Nsubj){
b0[i] ~ dnorm(0,tau_b0)
}
}"
runjags.options(method = "rjparallel")
#parameters = c("sigma", "beta2", "beta0", "beta1", "b0","predict","b0.rep","ppo")
parameters = c("sigma", "beta1", "b0","predict","b0.rep","ppo","sigma_b0")
model.function <- "model{
for (i in 1:N){
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]+ b0[id[i]]
predict[i]  ~ dlnorm(mu[i], sigma)
}
# forecast <- y[] - predict[]
#priors
sigma ~ dgamma(0.001, 0.001)
tau_b0 <- 1/sigma_b0
sigma_b0 ~ dunif(0,100)
beta0 ~ dnorm(0,0.000001)
beta1 ~ dnorm(0,0.000001)
beta2 ~ dnorm(0,0.000001)
for ( i in 1:Nsubj){
b0[i] ~ dnorm(0,tau_b0)
# Distribution of future b0_i
b0.rep[i] ~ dnorm(0,tau_b0)
}
for (i in 1:N){
ppo[i] <- dlnorm(y[i],mu[i],sigma)
}
# PPCs checking distribution of theta
# min and max of residuals
tmin1 <- sort(b0[])
tmin <- tmin1[1]
tmax1 <- sort(b0[])
tmax <- tmax1[Nsubj]
tmin.rep1 <- sort(b0_rep[])
tmin.rep <-  tmin.rep1[1]
tmax.rep1 <- sort(b0_rep[])
tmax.rep <- tmax.rep1[Nsubj]
tmin.test <- step(tmin.rep-tmin)
tmax.test <- step(tmax.rep-tmax)
# Kolmogorov-Smirnov test for residuals
for (i in 1:Nsubj){
F.gauss[i] <- phi( rank_b0[i])
F.gauss.rep[i] <-  phi( rank_b0_rep[i])
F.diff[i] <- max(F.gauss[i]-(i-1)/Nsubj,i/Nsubj-F.gauss[i])
F.diff.rep[i] <- max(F.gauss.rep[i]-(i-1)/Nsubj,i/Nsubj-F.gauss.rep[i])
}
ks1 <- sort(F.diff[])
ks <- ks1[Nsubj]
ks.rep <- sort(F.diff.rep[])
ks.rep2 <- ks.rep[Nsubj]
ks.test <- step(ks.rep2-ks)
# Sinharay and Stern test
#hard coding since we have 20 random effects this is fine
nmed <- round(20/2)
tmed1 <- sort(b0[])
tmed <- tmed1[nmed]
tmed.rep1 <- sort(b0_rep[])
tmed.rep <- tmed1[nmed]
ss <- abs(tmax-tmed)-abs(tmin-tmed)
ss.rep <-abs(tmax.rep-tmed.rep)-abs(tmin.rep-tmed.rep)
ss.test <- step(ss.rep-ss)
}"
lognorm_rand_rep <- run.jags(model = model.function,
monitor = parameters, data = model.data,
inits = model.inits, burnin = 2000,
sample = 5000, thin = 1, n.chains = 2)
model.function <- "model{
for (i in 1:N){
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]+ b0[id[i]]
predict[i]  ~ dlnorm(mu[i], sigma)
}
# forecast <- y[] - predict[]
#priors
sigma ~ dgamma(0.001, 0.001)
tau_b0 <- 1/sigma_b0
sigma_b0 ~ dunif(0,100)
beta0 ~ dnorm(0,0.000001)
beta1 ~ dnorm(0,0.000001)
beta2 ~ dnorm(0,0.000001)
for ( i in 1:Nsubj){
b0[i] ~ dnorm(0,tau_b0)
# Distribution of future b0_i
b0_rep[i] ~ dnorm(0,tau_b0)
}
for (i in 1:N){
ppo[i] <- dlnorm(y[i],mu[i],sigma)
}
# PPCs checking distribution of theta
# min and max of residuals
tmin1 <- sort(b0[])
tmin <- tmin1[1]
tmax1 <- sort(b0[])
tmax <- tmax1[Nsubj]
tmin.rep1 <- sort(b0_rep[])
tmin.rep <-  tmin.rep1[1]
tmax.rep1 <- sort(b0_rep[])
tmax.rep <- tmax.rep1[Nsubj]
tmin.test <- step(tmin.rep-tmin)
tmax.test <- step(tmax.rep-tmax)
# Kolmogorov-Smirnov test for residuals
for (i in 1:Nsubj){
F.gauss[i] <- phi( rank_b0[i])
F.gauss.rep[i] <-  phi( rank_b0_rep[i])
F.diff[i] <- max(F.gauss[i]-(i-1)/Nsubj,i/Nsubj-F.gauss[i])
F.diff.rep[i] <- max(F.gauss.rep[i]-(i-1)/Nsubj,i/Nsubj-F.gauss.rep[i])
}
ks1 <- sort(F.diff[])
ks <- ks1[Nsubj]
ks.rep <- sort(F.diff.rep[])
ks.rep2 <- ks.rep[Nsubj]
ks.test <- step(ks.rep2-ks)
# Sinharay and Stern test
#hard coding since we have 20 random effects this is fine
nmed <- round(20/2)
tmed1 <- sort(b0[])
tmed <- tmed1[nmed]
tmed.rep1 <- sort(b0_rep[])
tmed.rep <- tmed1[nmed]
ss <- abs(tmax-tmed)-abs(tmin-tmed)
ss.rep <-abs(tmax.rep-tmed.rep)-abs(tmin.rep-tmed.rep)
ss.test <- step(ss.rep-ss)
}"
lognorm_rand_rep <- run.jags(model = model.function,
monitor = parameters, data = model.data,
inits = model.inits, burnin = 2000,
sample = 5000, thin = 1, n.chains = 2)
model.function <- "model{
for (i in 1:N){
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]+ b0[id[i]]
predict[i]  ~ dlnorm(mu[i], sigma)
}
# forecast <- y[] - predict[]
#priors
sigma ~ dgamma(0.001, 0.001)
tau_b0 <- 1/sigma_b0
sigma_b0 ~ dunif(0,100)
beta0 ~ dnorm(0,0.000001)
beta1 ~ dnorm(0,0.000001)
beta2 ~ dnorm(0,0.000001)
for (i in 1:N){
ppo[i] <- dlnorm(y[i],mu[i],sigma)
}
for ( i in 1:Nsubj){
b0[i] ~ dnorm(0,tau_b0)
# Distribution of future b0_i
b0_rep[i] ~ dnorm(0,tau_b0)
# Ranked thetas also for PPC
rank_b01[i,1:Nsubj] <- sort(b0[1:Nsubj])
rank_b0[i] <- rank_b01[i,i]
rank_b0_rep1[i,1:Nsubj]  <- sort(b0_rep[1:Nsubj])
rank_b0_rep[i] <- rank_b0_rep1[i,i]
}
# PPCs checking distribution of theta
# min and max of residuals
tmin1 <- sort(b0[])
tmin <- tmin1[1]
tmax1 <- sort(b0[])
tmax <- tmax1[Nsubj]
tmin.rep1 <- sort(b0_rep[])
tmin.rep <-  tmin.rep1[1]
tmax.rep1 <- sort(b0_rep[])
tmax.rep <- tmax.rep1[Nsubj]
tmin.test <- step(tmin.rep-tmin)
tmax.test <- step(tmax.rep-tmax)
# Kolmogorov-Smirnov test for residuals
for (i in 1:Nsubj){
F.gauss[i] <- phi( rank_b0[i])
F.gauss.rep[i] <-  phi( rank_b0_rep[i])
F.diff[i] <- max(F.gauss[i]-(i-1)/Nsubj,i/Nsubj-F.gauss[i])
F.diff.rep[i] <- max(F.gauss.rep[i]-(i-1)/Nsubj,i/Nsubj-F.gauss.rep[i])
}
ks1 <- sort(F.diff[])
ks <- ks1[Nsubj]
ks.rep <- sort(F.diff.rep[])
ks.rep2 <- ks.rep[Nsubj]
ks.test <- step(ks.rep2-ks)
# Sinharay and Stern test
#hard coding since we have 20 random effects this is fine
nmed <- round(20/2)
tmed1 <- sort(b0[])
tmed <- tmed1[nmed]
tmed.rep1 <- sort(b0_rep[])
tmed.rep <- tmed1[nmed]
ss <- abs(tmax-tmed)-abs(tmin-tmed)
ss.rep <-abs(tmax.rep-tmed.rep)-abs(tmin.rep-tmed.rep)
ss.test <- step(ss.rep-ss)
}"
lognorm_rand_rep <- run.jags(model = model.function,
monitor = parameters, data = model.data,
inits = model.inits, burnin = 2000,
sample = 5000, thin = 1, n.chains = 2)
View(model.data)
