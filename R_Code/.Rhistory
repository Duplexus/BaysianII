y <- 3 + x2 + rnorm(100)
x <- runif(10,0,10)
x2 <- rep(x,each = 10)
id <- rep(1:10, each = 10)
y <- 3 + x2 + rnorm(100)
lm(y ~ id)
id <- as.factor(rep(1:10, each = 10))
y <- 3 + x2 + rnorm(100)
lm(y ~ id)
summary(lm(y ~ id))
x <- runif(10,5,10)
x2 <- rep(x,each = 10)
id <- as.factor(rep(1:10, each = 10))
y <- 3 + x2 + rnorm(100)
summary(lm(y ~ id))
group <- rep(1:2, each = 50)
group <- as.factor(rep(1:2, each = 50))
x <- runif(10,5,10)
x2 <- rep(x,each = 10)
x3 <- rep(c(2,5), each = 50)
group <- as.factor(rep(1:2, each = 50))
id <- as.factor(rep(1:10, each = 10))
y <- 3 + group + id + rnorm(100)
y <- 3 + x2 + x3 + rnorm(100)
summary(lm(y ~ id + group))
knitr::opts_chunk$set(echo = TRUE)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("helpfunctions.r")
library("runjags")
library("coda")
library("rjags")
library("survival")
source("Bayes1_Weibull_Random_jags.R")
#coda integration so also coda stuff is available
#Model Diagnostik plots
mcmc_weibull_rand <- as.mcmc.list(weibull_rand)
summary(mcmc_weibull_rand)
summary(weibull_rand)
extract.runjags(weibull_rand, "dic")
subset_pred <- grepl("ppo\\[", dimnames(weibull_rand_mcmc_rep[[1]])[[2]])
mcmc_subset <- get_values(weibull_rand_mcmc_rep,subset_pred)
#ppo which are now far of?
plot(1/apply(as.matrix(mcmc_subset),2,mean))
summary_weibull <- summary(weibull_rand_mcmc_rep)
b_params <- summary_weibull$statistics[grepl("b0\\[", dimnames(summary_weibull$statistics)[[1]]),]
mean(b_params[1:10,1])
attributes(summary_weibull$statistics)
#how unnormal the random effects
mean(get_values(weibull_rand_mcmc_rep,"tmax.test"))
mean(get_values(weibull_rand_mcmc_rep,"tmin.test"))
mean(get_values(weibull_rand_mcmc_rep,"ks.test"))
summary_weibull <- summary(weibull_rand_mcmc_rep)
b_params <- summary_weibull$statistics[grepl("b0\\[", dimnames(summary_weibull$statistics)[[1]]),]
#mean(b_params[1:10,1])
#attributes(summary_weibull$statistics)
#how unnormal the random effects
mean(get_values(weibull_rand_mcmc_rep,"tmax.test"))
mean(get_values(weibull_rand_mcmc_rep,"tmin.test"))
mean(get_values(weibull_rand_mcmc_rep,"ks.test"))
source("Bayes1_Weibull_Random_jags.R")
#coda integration so also coda stuff is available
#Model Diagnostik plots
mcmc_weibull_rand <- as.mcmc.list(weibull_rand)
summary(mcmc_weibull_rand)
summary(weibull_rand)
#coda integration so also coda stuff is available
#Model Diagnostik plots
mcmc_weibull_rand <- as.mcmc.list(weibull_rand)
summary(mcmc_weibull_rand)
summary(weibull_rand)
#coda integration so also coda stuff is available
#Model Diagnostik plots
mcmc_weibull_rand <- as.mcmc.list(weibull_rand)
print("gelman diag")
gelman.diag(mcmc_weibull_rand, confidence = 0.95)
gelman.plot(mcmc_weibull_rand, confidence = 0.95)
print("geweke diag")
geweke.diag(mcmc_weibull_rand)
geweke.plot(mcmc_weibull_rand)
subset_pred <- grepl("ppo\\[", dimnames(weibull_rand_mcmc_rep[[1]])[[2]])
mcmc_subset <- get_values(weibull_rand_mcmc_rep,subset_pred)
#ppo which are now far of?
plot(1/apply(as.matrix(mcmc_subset),2,mean))
plot(weibull_rand)
#The DIC Value for model comparison
cat("second kind of the plots seen before")
plot(mcmc_weibull_rand)
summary_weibull <- summary(weibull_rand_mcmc_rep)
b_params <- summary_weibull$statistics[grepl("b0\\[", dimnames(summary_weibull$statistics)[[1]]),]
#mean(b_params[1:10,1])
#attributes(summary_weibull$statistics)
#how unnormal the random effects
mean(get_values(weibull_rand_mcmc_rep,"tmax.test"))
mean(get_values(weibull_rand_mcmc_rep,"tmin.test"))
mean(get_values(weibull_rand_mcmc_rep,"ks.test"))
source("Bayes1_lognormal_Random_jags.R")
#coda integration so also coda stuff is available
#Model Diagnostik plots
mcmc_lognorm_rand <- as.mcmc.list(lognorm_rand)
summary(mcmc_lognorm_rand)
summary(lognorm_rand)
plot(lognorm_rand)
print(lognorm_rand)
#The DIC Value for model comparison
cat("second kind of the plots seen before")
plot(mcmc_lognorm_rand)
summary_weibull <- summary(weibull_rand_mcmc_rep)
b_params <- summary_weibull$statistics[grepl("b0\\[", dimnames(summary_weibull$statistics)[[1]]),]
#mean(b_params[1:10,1])
#attributes(summary_weibull$statistics)
#how unnormal the random effects
mean(get_values(weibull_rand_mcmc_rep,"tmax.test"))
mean(get_values(weibull_rand_mcmc_rep,"tmin.test"))
mean(get_values(weibull_rand_mcmc_rep,"ks.test"))
source("Bayes1_Weibull_Random_jags.R")
#coda integration so also coda stuff is available
#Model Diagnostik plots
mcmc_weibull_rand <- as.mcmc.list(weibull_rand)
summary(mcmc_weibull_rand)
summary(weibull_rand)
summary_weibull <- summary(weibull_rand_mcmc_rep)
b_params <- summary_weibull$statistics[grepl("b0\\[", dimnames(summary_weibull$statistics)[[1]]),]
#mean(b_params[1:10,1])
#attributes(summary_weibull$statistics)
#how unnormal the random effects
mean(get_values(weibull_rand_mcmc_rep,"tmax.test"))
mean(get_values(weibull_rand_mcmc_rep,"tmin.test"))
mean(get_values(weibull_rand_mcmc_rep,"ks.test"))
plot(weibull_rand)
#The DIC Value for model comparison
cat("second kind of the plots seen before")
plot(mcmc_weibull_rand)
source("Bayes1_Weibull_Random_jags.R")
#coda integration so also coda stuff is available
#Model Diagnostik plots
mcmc_weibull_rand <- as.mcmc.list(weibull_rand)
summary(mcmc_weibull_rand)
summary(weibull_rand)
plot(weibull_rand)
#The DIC Value for model comparison
cat("second kind of the plots seen before")
plot(mcmc_weibull_rand)
source("Bayes1_Weibull_Random_jags.R")
source("Bayes1_Weibull_Random_jags.R")
#coda integration so also coda stuff is available
#Model Diagnostik plots
mcmc_weibull_rand <- as.mcmc.list(weibull_rand)
summary(mcmc_weibull_rand)
summary(weibull_rand)
plot(weibull_rand)
#The DIC Value for model comparison
cat("second kind of the plots seen before")
plot(mcmc_weibull_rand)
summary_weibull <- summary(weibull_rand_mcmc_rep)
b_params <- summary_weibull$statistics[grepl("b0\\[", dimnames(summary_weibull$statistics)[[1]]),]
#mean(b_params[1:10,1])
#attributes(summary_weibull$statistics)
#how unnormal the random effects
mean(get_values(weibull_rand_mcmc_rep,"tmax.test"))
mean(get_values(weibull_rand_mcmc_rep,"tmin.test"))
mean(get_values(weibull_rand_mcmc_rep,"ks.test"))
source("Bayes1_Weibull_Random_jags.R")
#coda integration so also coda stuff is available
#Model Diagnostik plots
mcmc_weibull_rand <- as.mcmc.list(weibull_rand)
summary(mcmc_weibull_rand)
summary(weibull_rand)
plot(weibull_rand)
#The DIC Value for model comparison
cat("second kind of the plots seen before")
plot(mcmc_weibull_rand)
#coda integration so also coda stuff is available
#Model Diagnostik plots
mcmc_weibull_rand <- as.mcmc.list(weibull_rand)
summary(mcmc_weibull_rand)
summary(weibull_rand)
source("Bayes1_Weibull_Random_jags.R")
#coda integration so also coda stuff is available
#Model Diagnostik plots
mcmc_weibull_rand <- as.mcmc.list(weibull_rand)
summary(mcmc_weibull_rand)
summary(weibull_rand)
summary_weibull <- summary(weibull_rand_mcmc_rep)
b_params <- summary_weibull$statistics[grepl("b0\\[", dimnames(summary_weibull$statistics)[[1]]),]
#mean(b_params[1:10,1])
#attributes(summary_weibull$statistics)
#how unnormal the random effects
mean(get_values(weibull_rand_mcmc_rep,"tmax.test"))
mean(get_values(weibull_rand_mcmc_rep,"tmin.test"))
mean(get_values(weibull_rand_mcmc_rep,"ks.test"))
#Bayes1_Weibull_random.r
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
set.seed(124234)
source("helpfunctions.r")
library("runjags")
library("coda")
library("rjags")
Grub <- read.csv("..\\data\\Grubs_Easy_normalized_size.csv")
model.data <- list( y = Grub$value, N = length(Grub$value), x1 = Grub$grubsize,
x2 = Grub$group, id = Grub$id, Nsubj = length(unique(Grub$id)))
# MODEL SPECIFICATION
model.function <- "model{
for (i in 1:N){
y[i] ~ dweib(k, invlambda[i])
#log(invlambda[i]) <- beta0 + beta1 *x1[i] + beta2 *x2[i] + b0[id[i]]
log(invlambda[i]) <- beta1 *x1[i] + b0[id[i]]
}
#priors
k ~ dunif(0,100)
beta0 ~ dnorm(0,0.000001)
beta1 ~ dnorm(0,0.000001)
sigma ~ dunif(0,100)
beta2 ~ dnorm(0,0.000001)
for ( i in 1:Nsubj){
b0[i] ~ dnorm(mean(beta0 + beta2 *x2[i:(i+6)]) ,sigma)
}
}"
#Monitored Variables
# parameters <- c("k", "beta2", "beta0", "beta1", "b0")
parameters <- c("k", "beta1", "b0", "b0_rep", "sigma")
model.inits <- list(list(k=2, beta0=1, beta1 = 1,beta2 = 1, b0 = c(rep(1,times = 20))),
list(k=2, beta0=1, beta1 = 1,beta2 = 1, b0 = c(rep(1,times = 20))))
runjags.options(method = "rjparallel")
#Set Up Model
weibull_rand <- run.jags(model = model.function,
monitor = parameters, data = model.data,
inits = model.inits, burnin = 2000,
sample = 5000, thin = 1, n.chains = 2)
model.inits <- list(list(k=2, beta0=1, beta1 = 1,beta2 = 1, b0 = c(rep(1,times = 20)),b0_rep = c(rep(1,times = 20))),
list(k=2, beta0=1, beta1 = 1,beta2 = 1, b0 = c(rep(1,times = 20)),b0_rep = c(rep(1,times = 20))))
runjags.options(method = "rjparallel")
source("helpfunctions.r")
library("runjags")
library("coda")
library("rjags")
Grub <- read.csv("..\\data\\Grubs_Easy_normalized_size.csv")
model.data <- list( y = Grub$value, N = length(Grub$value), x1 = Grub$grubsize,
x2 = Grub$group, id = Grub$id, Nsubj = length(unique(Grub$id)))
# MODEL SPECIFICATION
model.function <- "model{
for (i in 1:N){
y[i] ~ dweib(k, invlambda[i])
#log(invlambda[i]) <- beta0 + beta1 *x1[i] + beta2 *x2[i] + b0[id[i]]
log(invlambda[i]) <- beta1 *x1[i] + b0[id[i]]
}
#priors
k ~ dunif(0,100)
beta0 ~ dnorm(0,0.000001)
beta1 ~ dnorm(0,0.000001)
sigma ~ dunif(0,100)
beta2 ~ dnorm(0,0.000001)
for ( i in 1:Nsubj){
b0[i] ~ dnorm(mean(beta0 + beta2 *x2[i:(i+6)]) ,sigma)
}
}"
#Monitored Variables
parameters <- c("k", "sigma", "beta2", "beta0", "beta1", "b0_rep")
model.inits <- list(list(k=2, beta0=1, beta1 = 1,beta2 = 1, b0 = c(rep(1,times = 20)),b0_rep = c(rep(1,times = 20))),
list(k=2, beta0=1, beta1 = 1,beta2 = 1, b0 = c(rep(1,times = 20)),b0_rep = c(rep(1,times = 20))))
runjags.options(method = "rjparallel")
#Set Up Model
weibull_rand <- run.jags(model = model.function,
monitor = parameters, data = model.data,
inits = model.inits, burnin = 2000,
sample = 5000, thin = 1, n.chains = 2)
plot(weibull_rand)
# MODEL SPECIFICATION
model.function <- "model{
for (i in 1:N){
y[i] ~ dweib(k, invlambda[i])
#log(invlambda[i]) <- beta0 + beta1 *x1[i] + beta2 *x2[i] + b0[id[i]]
log(invlambda[i]) <- beta1 *x1[i] + b0[id[i]]
}
#priors
k ~ dunif(0,100)
beta0 ~ dnorm(0,0.000001)
beta1 ~ dnorm(0,0.000001)
sigma ~ dunif(0,100)
beta2 ~ dnorm(0,0.000001)
for ( i in 1:Nsubj){
b0[i] ~ dnorm(mean(beta0 + beta2 *x2[i:(i+6)]) ,sigma)
b0_rep[i] ~ dnorm(mean(beta0 + beta2 *x2[i:(i+6)]) ,sigma)
}
}"
#Monitored Variables
parameters <- c("k", "sigma", "beta2", "beta0", "beta1", "b0_rep")
model.inits <- list(list(k=2, beta0=1, beta1 = 1,beta2 = 1, b0 = c(rep(1,times = 20)),b0_rep = c(rep(1,times = 20))),
list(k=2, beta0=1, beta1 = 1,beta2 = 1, b0 = c(rep(1,times = 20)),b0_rep = c(rep(1,times = 20))))
runjags.options(method = "rjparallel")
#Set Up Model
weibull_rand <- run.jags(model = model.function,
monitor = parameters, data = model.data,
inits = model.inits, burnin = 2000,
sample = 5000, thin = 1, n.chains = 2)
plot(weibull_rand)
model.function <- "model{
for (i in 1:N1){
z[i] ~ dinterval(y[i], lims[i, ])
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]
}
for (i in (N1+1):(N1+N2)){
z[i] ~ dinterval(y[i], lims[i,])
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]
}
#priors
sigma ~ dgamma(0.001, 0.001)
beta0 ~ dnorm(0,0.000001)
beta1 ~ dnorm(0,0.000001)
beta2 ~ dnorm(0,0.000001)
#ppc look on residuals
for (i in 1:N){
ppo[i] <- dlnorm(y[i],mu[i],sigma)
k[i] <- log(y[i])
res[i] <- k[i] - mu[i]
#for DIC
D[i] <- -2*log(dlnorm(y[i],mu[i], sigma))
}
K <- sort(D)
K <- K[2]
Deviance <- sum(D[])
}"
runjags.options(method = "rjparallel")
parameters <-c("beta0", "beta1", "beta2", "sigma","ppo","res","mu","Deviance")
lognorm_cens_rep <- run.jags(model = model.function,
monitor = parameters, data = model.data,
inits = model.inits, burnin = 2000, sample = 5000, thin = 1, n.chains = 2
, progress.bar = "text")
model.data <- list(y = Grub$value, z = Grub$state, N1 = length_Upper,N2 = lenngth_NA_Upper, x1 = Grub$grubsize,
x2 = Grub$group, lims = cbind(Grub$lowerlim,Grub$upperlim))
lognorm_cens_rep <- run.jags(model = model.function,
monitor = parameters, data = model.data,
inits = model.inits, burnin = 2000, sample = 5000, thin = 1, n.chains = 2
, progress.bar = "text")
model.data
length_Upper
Grub <- read.csv("..\\data\\Grubs_Easy_normalized_size.csv")
Grub <- Grub %>% arrange(upperlim)
length_Upper <- length(sort(Grub$upperlim))
library("dplyr")
Grub <- read.csv("..\\data\\Grubs_Easy_normalized_size.csv")
Grub <- Grub %>% arrange(upperlim)
length_Upper <- length(sort(Grub$upperlim))
#10
lenngth_NA_Upper <- nrow(Grub) - length_Upper
NAs <- is.na(Grub$upperlim)
#just for numerical reasons, second has to be bigger than first
#and just to lazy to separate therefore makes no difference
Grub$upperlim[NAs] <- 12.000001
# PPO
#da alle Intervallcensored sind gerade muss ich immer eine 1 schicken
#https://stats.stackexchange.com/questions/13847/how-does-dinterval-for-interval-censored-data-work-in-jags
Grub$state <- c(rep(1,length_Upper),rep(2,lenngth_NA_Upper))
#also helpfull to understand later syntax: https://stats.stackexchange.com/questions/70858/right-censored-survival-fit-with-jags
Grub$value <- as.numeric(NA)
model.data <- list(y = Grub$value, z = Grub$state, N1 = length_Upper,N2 = lenngth_NA_Upper, x1 = Grub$grubsize,
x2 = Grub$group, lims = cbind(Grub$lowerlim,Grub$upperlim))
model.inits <- list(list(sigma=2, beta0=1, beta1 = 1,beta2 = 1 ),list(sigma=2, beta0=1, beta1 = 1,beta2 = 1 ))
parameters <-c("beta0", "beta1", "beta2", "sigma")
model.function <- "model{
for (i in 1:N1){
z[i] ~ dinterval(y[i], lims[i, ])
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]
}
for (i in (N1+1):(N1+N2)){
z[i] ~ dinterval(y[i], lims[i,])
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]
}
#priors
sigma ~ dgamma(0.001, 0.001)
beta0 ~ dnorm(0,0.000001)
beta1 ~ dnorm(0,0.000001)
beta2 ~ dnorm(0,0.000001)
}"
runjags.options(method = "rjparallel")
lognorm_cens <- run.jags(model = model.function,
monitor = parameters, data = model.data,
inits = model.inits, burnin = 1000, sample = 10000, thin = 1, n.chains = 2
, progress.bar = "text")
lognorm_cens_mcmc <- as.mcmc.list(lognorm_cens)
model.function <- "model{
for (i in 1:N1){
z[i] ~ dinterval(y[i], lims[i, ])
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]
}
for (i in (N1+1):(N1+N2)){
z[i] ~ dinterval(y[i], lims[i,])
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]
}
#priors
sigma ~ dgamma(0.001, 0.001)
beta0 ~ dnorm(0,0.000001)
beta1 ~ dnorm(0,0.000001)
beta2 ~ dnorm(0,0.000001)
#ppc look on residuals
for (i in 1:N){
ppo[i] <- dlnorm(y[i],mu[i],sigma)
k[i] <- log(y[i])
res[i] <- k[i] - mu[i]
#for DIC
D[i] <- -2*log(dlnorm(y[i],mu[i], sigma))
}
K <- sort(D)
K <- K[2]
Deviance <- sum(D[])
}"
runjags.options(method = "rjparallel")
parameters <-c("beta0", "beta1", "beta2", "sigma","ppo","res","mu","Deviance")
lognorm_cens_rep <- run.jags(model = model.function,
monitor = parameters, data = model.data,
inits = model.inits, burnin = 2000, sample = 5000, thin = 1, n.chains = 2
, progress.bar = "text")
model.function <- "model{
for (i in 1:N1){
z[i] ~ dinterval(y[i], lims[i, ])
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]
}
for (i in (N1+1):(N1+N2)){
z[i] ~ dinterval(y[i], lims[i,])
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]
}
#priors
sigma ~ dgamma(0.001, 0.001)
beta0 ~ dnorm(0,0.000001)
beta1 ~ dnorm(0,0.000001)
beta2 ~ dnorm(0,0.000001)
#ppc look on residuals
for (i in 1:(N1+N2)){
ppo[i] <- dlnorm(y[i],mu[i],sigma)
k[i] <- log(y[i])
res[i] <- k[i] - mu[i]
#for DIC
D[i] <- -2*log(dlnorm(y[i],mu[i], sigma))
}
K <- sort(D)
K <- K[2]
Deviance <- sum(D[])
}"
runjags.options(method = "rjparallel")
parameters <-c("beta0", "beta1", "beta2", "sigma","ppo","res","mu","Deviance")
lognorm_cens_rep <- run.jags(model = model.function,
monitor = parameters, data = model.data,
inits = model.inits, burnin = 2000, sample = 5000, thin = 1, n.chains = 2
, progress.bar = "text")
model.function <- "model{
for (i in 1:N1){
z[i] ~ dinterval(y[i], lims[i, ])
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]
}
for (i in (N1+1):(N1+N2)){
z[i] ~ dinterval(y[i], lims[i,])
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]
}
#priors
sigma ~ dgamma(0.001, 0.001)
beta0 ~ dnorm(0,0.000001)
beta1 ~ dnorm(0,0.000001)
beta2 ~ dnorm(0,0.000001)
#ppc look on residuals
for (i in 1:(N1+N2)){
ppo[i] <- dlnorm(y[i],mu[i],sigma)
k[i] <- log(y[i])
res[i] <- k[i] - mu[i]
#for DIC
D[i] <- -2*log(dlnorm(y[i],mu[i], sigma))
}
Deviance <- sum(D[])
}"
runjags.options(method = "rjparallel")
parameters <-c("beta0", "beta1", "beta2", "sigma","ppo","res","mu","Deviance")
lognorm_cens_rep <- run.jags(model = model.function,
monitor = parameters, data = model.data,
inits = model.inits, burnin = 2000, sample = 5000, thin = 1, n.chains = 2
, progress.bar = "text")
#10
Grub$value
#also helpfull to understand later syntax: https://stats.stackexchange.com/questions/70858/right-censored-survival-fit-with-jags
Grub$value2 <- as.numeric(NA)
parameters <-c("beta0", "beta1", "beta2", "sigma","ppo","res","mu","Deviance","y")
lognorm_cens_rep <- run.jags(model = model.function,
monitor = parameters, data = model.data,
inits = model.inits, burnin = 2000, sample = 5000, thin = 1, n.chains = 2
, progress.bar = "text")
lognorm_cens_rep_mcmc <- as.mcmc.list(lognorm_cens_rep)
subset_pred <- grepl("y///]", dimnames(lognorm_cens_rep_mcmc[[1]])[[2]])
subset_pred
subset_pred <- grepl("y//]", dimnames(lognorm_cens_rep_mcmc[[1]])[[2]])
subset_pred <- grepl("y//[", dimnames(lognorm_cens_rep_mcmc[[1]])[[2]])
subset_pred <- grepl("y\\[", dimnames(lognorm_cens_rep_mcmc[[1]])[[2]])
subset_pred
mcmc_subset <- get_values(lognorm_cens_rep_mcmc,subset_pred)
mcmc_subset
apply(mcmc_subset,2,mean)
mcmc_subset
min(mcmc_subset|mcmc_subset>0.1)
min(mcmc_subset|mcmc_subset>2)
min(mcmc_subset|mcmc_subset>3)
mcmc_subset[mcmc_subset<12] <- 900
min(mcmc_subset)
subset_pred <- grepl("y\\[", dimnames(lognorm_cens_rep_mcmc[[1]])[[2]])
mcmc_subset <- get_values(lognorm_cens_rep_mcmc,subset_pred)
apply(mcmc_subset,2,mean)
Grub$sim_value <- apply(mcmc_subset,2,mean)
