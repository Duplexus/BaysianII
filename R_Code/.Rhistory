pnorm(0)
qnorm(0)
qnorm(1)
qnorm(0.4)
dnorm(sd = 2)
dnorm(0,sd = 2)
dnorm(0,sd = 0.25)
dnorm(seq(0,1, by = 0.001),sd = 0.25)
mean(dnorm(seq(0,1, by = 0.001),sd = 0.25))
mean(dnorm(0, mean = seq(0,1, by = 0.001),sd = 0.25))
mean(dnorm(0.5, mean = seq(0,1, by = 0.001) ,sd = 0.25))
mean(dnorm(0.6, mean = seq(0,1, by = 0.001) ,sd = 0.25))
mean(dnorm(0.9, mean = seq(0,1, by = 0.001) ,sd = 0.25))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.25))
mean(dnorm(2, mean = seq(0,1, by = 0.001) ,sd = 0.25))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.25))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.25))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.5/1.96))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.3))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.28))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.29))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.285))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.289))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.289))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.29))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.295))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.3))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.32))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.26))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.27))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.28))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.284))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.283))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.282))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.283))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.284))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.2833))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.2832))
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.2831))
0.5/0.2831
pnorm(0.5, sd = 0.25)
pnorm(-0.5, sd = 0.25)
pnorm(-0.5, sd = 0.25)*2
pnorm(-0.5, sd = 0.2831)*2
pnorm(-0.5, sd = 0.26)*2
pnorm(-0.5, sd = 0.254)*2
pnorm(-0.5, sd = 0.255)*2
pnorm(-0.5, sd = 0.256)*2
pnorm(-0.5, sd = 0.255)*2
mean(dnorm(0, mean = seq(0,1, by = 0.001) ,sd = 0.25))
mean(dnorm(0, mean = seq(-10,10, by = 0.001) ,sd = 0.25))
mean(dnorm(0, mean = seq(-10,0, by = 0.001) ,sd = 0.25))
mean(dnorm(0, mean = seq(-100,0, by = 0.001) ,sd = 0.25))
sum(dnorm(0, mean = seq(-100,0, by = 0.001) ,sd = 0.25))
sum(dnorm(0, mean = seq(-1000,0, by = 0.001) ,sd = 0.25))
sum(dnorm(0, mean = seq(-10,0, by = 0.001) ,sd = 0.25))
sum(dnorm(0, mean = seq(-1,0, by = 0.001) ,sd = 0.25))
sum(dnorm(0, mean = seq(-0.2,0, by = 0.001) ,sd = 0.25))
sum(dnorm(0, mean = seq(-10,0, by = 0.001) ,sd = 0.25))
sum(dnorm(2, mean = seq(-10,0, by = 0.001) ,sd = 0.25))
sum(dnorm(1, mean = seq(-10,0, by = 0.001) ,sd = 0.25))
sum(dnorm(1, mean = seq(-10,0, by = 0.001) ,sd = 0.25))
sum(dnorm(0, mean = seq(-10,0, by = 0.001) ,sd = 0.25))
plot(z,sum(dnorm(z, mean = seq(-10,0, by = 0.001) ,sd = 0.25)))
z <- seq(0,1, by = 0.001)
plot(z,sum(dnorm(z, mean = seq(-10,0, by = 0.001) ,sd = 0.25)))
plot(z,sapply(z, p_steck_unten))
p_steck_unten <- function(z){
sum(dnorm(z, mean = seq(-10,0, by = 0.001) ,sd = 0.25))
}
plot(z,sapply(z, p_steck_unten))
plot(z,sapply(z, p_steck_unten), type = "l")
p_steck_oben <- function(z){
sum(dnorm(z, mean = seq(1,11, by = 0.001) ,sd = 0.25))
}
plot(z,sapply(z, p_steck_oben), type = "l")
plot(z,sapply(z, p_steck_unten)/p_steck_oben(0), type = "l")
plot(z,sapply(z, p_steck_unten)/(2*p_steck_unten(0)), type = "l")
p_steck_unten <- function(z){
steck_unten_approx <- function(z){
return(sum(dnorm(z, mean = seq(-10,0, by = 0.001) ,sd = 0.25)))
}
#die Wahrscheinlichkeit auf Untenstecken für 0 (ist ja ungefähr
# 0.5 da über 4 sd sehr unwahrscheinlich) normalisieren
return(steck_unten_approx(z)/ steck_unten_approx(0))
}
p_steck_unten(0)
steck_unten_approx <- function(z){
return(sum(dnorm(z, mean = seq(-10,0, by = 0.001) ,sd = 0.25)))
}
p_steck_unten <- function(z){
steck_unten_approx <- function(z){
return(sum(dnorm(z, mean = seq(-10,0, by = 0.001) ,sd = 0.25)))
}
#die Wahrscheinlichkeit auf Untenstecken für 0 (ist ja ungefähr
# 0.5 da über 4 sd sehr unwahrscheinlich) normalisieren
return(steck_unten_approx(z)/ (steck_unten_approx(0)*2))
}
p_steck_unten(0)
p_steck_unten(1)
p_steck_unten(0.3)
p_steck_unten(0.2)
p_steck_unten(0.1)
p_steck_unten <- function(z){
steck_unten_approx <- function(z){
return(sum(dnorm(z, mean = seq(-10,0, by = 0.0001) ,sd = 0.25)))
}
#die Wahrscheinlichkeit auf Untenstecken für 0 (ist ja ungefähr
# 0.5 da über 4 sd sehr unwahrscheinlich) normalisieren
return(steck_unten_approx(z)/ (steck_unten_approx(0)*2))
}
p_steck_unten(0.1)
p_steck_unten <- function(z){
steck_unten_approx <- function(z){
return(sum(dnorm(z, mean = seq(-10,0, by = 0.0001) ,sd = 0.1)))
}
#die Wahrscheinlichkeit auf Untenstecken für 0 (ist ja ungefähr
# 0.5 da über 4 sd sehr unwahrscheinlich) normalisieren
return(steck_unten_approx(z)/ (steck_unten_approx(0)*2))
}
p_steck_unten(0.1)
p_steck_unten <- function(z){
steck_unten_approx <- function(z){
return(sum(dnorm(z, mean = seq(-10,0, by = 0.001) ,sd = 0.1)))
}
#die Wahrscheinlichkeit auf Untenstecken für 0 (ist ja ungefähr
# 0.5 da über 4 sd sehr unwahrscheinlich) normalisieren
return(steck_unten_approx(z)/ (steck_unten_approx(0)*2))
}
p_steck_unten(0.1)
p_steck_oben <- function(z){
steck_oben_approx <- function(z){
return(sum(dnorm(z, mean = seq(1,11, by = 0.001) ,sd = 0.25)))
}
return(steck_oben_approx(z)/ (steck_oben_approx(1)*2))
}
#normalisieren auf 0.5
plot(z,sapply(z, p_steck_unten)/(2*p_steck_unten(0)), type = "l")
plot(z,sapply(z, p_steck_oben), type = "l")
#normalisieren auf 0.5
plot(z,sapply(z, p_steck_unten), type = "l")
mean(dnorm(1, mean = seq(0,1, by = 0.001) ,sd = 0.25))
mean(dnorm(1, mean = seq(0,1, by = 0.0001) ,sd = 0.25))
mean(dnorm(1, mean = seq(0,1, by = 0.00001) ,sd = 0.25))
mean(dnorm(0.5, mean = seq(0,1, by = 0.0001) ,sd = 0.25))
mean(dnorm(1, mean = seq(0,1, by = 0.0001) ,sd = 0.25))
mean(dnorm(0, mean = seq(0,1, by = 0.0001) ,sd = 0.25))
mean(dnorm(0, mean = seq(0,1, by = 0.000001) ,sd = 0.25))
mean(dnorm(0, mean = seq(0,1, by = 0.0001) ,sd = 0.25))
mean(dnorm(0, mean = seq(0,1, by = 0.0001) ,sd = 0.25))
mean(dnorm(0.5, mean = seq(0,1, by = 0.0001) ,sd = 0.25))
pnorm(0.5)
pnorm(mean = 0.5, sd = 0.25)
pnorm(0, mean = 0.5, sd = 0.025)
pnorm(0, mean = 0.5, sd = 0.25)
1 - 2 * pnorm(0, mean = 0.5, sd = 0.25)
mean(dnorm(0.5, mean = seq(0,1, by = 0.0001) ,sd = 0.25))
mean(dnorm(0, mean = seq(0,1, by = 0.0001) ,sd = 0.25))
pnorm(0, mean = 4, sd = 4)
pnorm(0, mean = 4, sd = 1)
pnorm(0, mean = 4, sd = 1) + pnorm(4, mean = 4, sd = 1)
plot(z,mean(dnorm(z, mean = seq(0,1, by = 0.0001) ,sd = 0.25)))
plot(z,mean(dnorm(z, mean = seq(0,1, by = 0.0001) ,sd = 0.25)))
#logisches Ergebnis, da ist quasi die Frage, was ist die durchschnitt
#liche dichte der einzelnen Verteilungsfunktionen. Da wir auf 0,1 arbeiten
# mit einer geringen sd. Ist für den mittelsten Wert die durcschnittliche Dichte
# ungefähr 0.95, da symetrische Wahrscheinlichkeit und das dann die FLäche
p_getroffen <- function(z){
return(mean(dnorm(z, mean = seq(0,1, by = 0.0001) ,sd = 0.25)))
}
p_getroffen(0)
p_getroffen(2)
p_getroffen(1)
plot(z,sapply(z, p_getroffen), type = "l")
plot(z,sapply(z, p_getroffen) + sapply(z, p_steck_oben) + sapply(z, p_steck_unten) , type = "l")
#normalisieren auf 0.5
plot(z,sapply(z, p_steck_unten), type = "l")
plot(z,sapply(z, p_steck_oben), type = "l")
plot(z,sapply(z, p_getroffen) + sapply(z, p_steck_oben) + sapply(z, p_steck_unten) , type = "l")
z <- seq(0,1, by = 0.01)
plot(z,sapply(z, p_getroffen) + sapply(z, p_steck_oben) + sapply(z, p_steck_unten) , type = "l")
p_steck_unten(0.4)
p_steck_oben(0.6)
p_steck_unten(0.1)
p_steck_oben(0.9)
p_steck_unten <- function(z){
return(p_steck_oben(1 - z))
}
p_steck_unten(0.1)
p_steck_oben(0.9)
#normalisieren auf 0.5
plot(z,sapply(z, p_steck_unten), type = "l")
plot(z,sapply(z, p_steck_oben), type = "l")
#logisches Ergebnis, da ist quasi die Frage, was ist die durchschnitt
#liche dichte der einzelnen Verteilungsfunktionen. Da wir auf 0,1 arbeiten
# mit einer geringen sd. Ist für den mittelsten Wert die durcschnittliche Dichte
# ungefähr 0.95, da symetrische Wahrscheinlichkeit und das dann die FLäche
p_getroffen <- function(z){
return(mean(dnorm(z, mean = seq(0,1, by = 0.0001) ,sd = 0.25)))
}
plot(z,sapply(z, p_getroffen) + sapply(z, p_steck_oben) + sapply(z, p_steck_unten) , type = "l")
p_steck_unten <- function(z){
steck_unten_approx <- function(z){
return(sum(dnorm(z, mean = seq(-10,0, by = 0.001) ,sd = 0.25)))
}
return(steck_unten_approx(z)/ (steck_unten_approx(0)*2))
}
p_steck_oben <- function(z){
return(p_steck_unten(1 - z))
}
p_steck_unten(0.1)
p_steck_oben(0.9)
#normalisieren auf 0.5
plot(z,sapply(z, p_steck_unten), type = "l")
plot(z,sapply(z, p_steck_oben), type = "l")
#logisches Ergebnis, da ist quasi die Frage, was ist die durchschnitt
#liche dichte der einzelnen Verteilungsfunktionen. Da wir auf 0,1 arbeiten
# mit einer geringen sd. Ist für den mittelsten Wert die durcschnittliche Dichte
# ungefähr 0.95, da symetrische Wahrscheinlichkeit und das dann die FLäche
p_getroffen <- function(z){
return(mean(dnorm(z, mean = seq(0,1, by = 0.0001) ,sd = 0.25)))
}
plot(z,sapply(z, p_getroffen) + sapply(z, p_steck_oben) + sapply(z, p_steck_unten) , type = "l")
a <-  p_getroffen) + sapply(z, p_steck_oben) + sapply(z, p_steck_unten)
a <-  sapply(z, p_getroffen) + sapply(z, p_steck_oben) + sapply(z, p_steck_unten)
a
source('C:/Valentin/Goettingen/3_Semester/Baysian_2/Metropolis.R', encoding = 'UTF-8')
a
# #die Wahrscheinlichkeit auf Untenstecken für 0 (ist ja ungefähr
# # 0.5 da über 4 sd sehr unwahrscheinlich) normalisieren
p_steck_oben <- function(z){
steck_oben_approx <- function(z){
return(sum(dnorm(z, mean = seq(1,11, by = 0.001) ,sd = 0.25)))
}
return(steck_oben_approx(z)/ (steck_oben_approx(1)*2))
}
a <-  sapply(z, p_getroffen) + sapply(z, p_steck_oben) + sapply(z, p_steck_unten)
a
plot(z,sapply(z, p_getroffen) + sapply(z, p_steck_oben) + sapply(z, p_steck_unten) , type = "l")
p_steck_unten(0.1)
p_steck_oben(0.9)
p_steck_unten <- function(z){
steck_unten_approx <- function(z){
return(sum(dnorm(z, mean = seq(-10,0, by = 0.001) ,sd = 0.25)))
}
return(steck_unten_approx(z)/ (steck_unten_approx(0)*2))
}
# #die Wahrscheinlichkeit auf Untenstecken für 0 (ist ja ungefähr
# # 0.5 da über 4 sd sehr unwahrscheinlich) normalisieren
p_steck_oben <- function(z){
steck_oben_approx <- function(z){
return(sum(dnorm(z, mean = seq(1,11, by = 0.001) ,sd = 0.25)))
}
return(steck_oben_approx(z)/ (steck_oben_approx(1)*2))
}
p_steck_unten(0.1)
p_steck_oben(0.9)
#normalisieren auf 0.5
plot(z,sapply(z, p_steck_unten), type = "l")
plot(z,sapply(z, p_steck_oben), type = "l")
#logisches Ergebnis, da ist quasi die Frage, was ist die durchschnitt
#liche dichte der einzelnen Verteilungsfunktionen. Da wir auf 0,1 arbeiten
# mit einer geringen sd. Ist für den mittelsten Wert die durcschnittliche Dichte
# ungefähr 0.95, da symetrische Wahrscheinlichkeit und das dann die FLäche
p_getroffen <- function(z){
return(mean(dnorm(z, mean = seq(0,1, by = 0.0001) ,sd = 0.25)))
}
plot(z,sapply(z, p_getroffen) + sapply(z, p_steck_oben) + sapply(z, p_steck_unten) , type = "l")
a <-  sapply(z, p_getroffen) + sapply(z, p_steck_oben) + sapply(z, p_steck_unten)
a
.libpaths()
install.packages("repr")
# cor(data_wide_model2[,7:18], use = "pairwise.complete.obs") %>%  round(3)
# cov(data[,1:12], use = "pairwise.complete.obs") %>%  round(1)
pchisq(52979-49017,3147-155)
# cor(data_wide_model2[,7:18], use = "pairwise.complete.obs") %>%  round(3)
# cov(data[,1:12], use = "pairwise.complete.obs") %>%  round(1)
pchisq(52979-41017,3147-155)
# cor(data_wide_model2[,7:18], use = "pairwise.complete.obs") %>%  round(3)
# cov(data[,1:12], use = "pairwise.complete.obs") %>%  round(1)
pchisq(52979-51017,3147-155)
# cor(data_wide_model2[,7:18], use = "pairwise.complete.obs") %>%  round(3)
# cov(data[,1:12], use = "pairwise.complete.obs") %>%  round(1)
pchisq(52979-49017,3147-155)
# cor(data_wide_model2[,7:18], use = "pairwise.complete.obs") %>%  round(3)
# cov(data[,1:12], use = "pairwise.complete.obs") %>%  round(1)
pchisq(52979-51017,3147-155)
# cor(data_wide_model2[,7:18], use = "pairwise.complete.obs") %>%  round(3)
# cov(data[,1:12], use = "pairwise.complete.obs") %>%  round(1)
pchisq(52979-49017,52979-49017)
52979-49017
data_long$year0.5 <- ifelse(data_long$years_after == 0.5, 1,0)
library(lme4)
#Bayes1_lognormal_random.r
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(coda)
library(R2OpenBUGS)
Grub <- read.csv("..\\data\\Grubs_Easy_normalized_size.csv")
model.data <- list( y = Grub$value, N = length(Grub$value), x1 = Grub$grubsize,
x2 = Grub$group, id = Grub$id, Nsubj = length(unique(Grub$id)))
model.function <- function(){
for (i in 1:N){
y[i] ~ dlnorm(mu[i], sigma)
#mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]+ b0[id[i]]
mu[i] <- beta1 *x1[i] + b0[id[i]]
}
#priors
sigma ~ dunif(0.1,100)
beta0 ~ dunif(-5,5)
beta1 ~ dunif(-5,5)
beta2 ~ dunif(-5,5)
for ( i in 1:Nsubj){
b0[i] ~ dnorm(0,0.1)
}
}
write.model(model.function, "Scripts\\Bayes1_lognormal_Random.txt")
model.inits <- function(){list(sigma=2, beta0=1, beta1 = 1,beta2 = 1, b0 = c(rep(1,times = 20)) )}
parameters = c("sigma", "beta2", "beta0", "beta1", "b0")
model.out <- bugs(model.data, model.inits,
model.file = "Bayes1_lognormal_Random.txt",
parameters=parameters,
n.chains = 1, n.iter = 5000,  n.burnin = 1000, debug = T,
codaPkg=T,
working.directory = ".\\Scripts")
model.function <- function(){
for (i in 1:N){
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]+ b0[id[i]]
#mu[i] <- beta1 *x1[i] + b0[id[i]]
}
#priors
sigma ~ dunif(0.1,100)
beta0 ~ dunif(-5,5)
beta1 ~ dunif(-5,5)
beta2 ~ dunif(-5,5)
for ( i in 1:Nsubj){
b0[i] ~ dnorm(0,0.1)
}
}
write.model(model.function, "Scripts\\Bayes1_lognormal_Random.txt")
model.inits <- function(){list(sigma=2, beta0=1, beta1 = 1,beta2 = 1, b0 = c(rep(1,times = 20)) )}
parameters = c("sigma", "beta2", "beta0", "beta1", "b0")
model.out <- bugs(model.data, model.inits,
model.file = "Bayes1_lognormal_Random.txt",
parameters=parameters,
n.chains = 1, n.iter = 5000,  n.burnin = 1000, debug = T,
codaPkg=T,
working.directory = ".\\Scripts")
#parametric
library(survival)
#lognormal Modell 1 no random effects
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(coda)
library(R2OpenBUGS)
Grub <- read.csv("..\\data\\Grubs_Easy.csv")
Grub$grubsize <- scale(Grub$grubsize)
attributes(Grub$grubsize) <- NULL
# Grub$group <- scale(Grub$group)
model.data <- list( y = Grub$value, N = length(Grub$value), x1 = Grub$grubsize,
x2 = Grub$group )
# MODEL SPECIFICATION
model.function <- function(){
for (i in 1:N){
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]
}
#priors
sigma ~ dunif(0.1,100)
beta0 ~ dunif(-5,5)
beta1 ~ dunif(-5,5)
beta2 ~ dunif(-5,5)
}
write.model(model.function, "Scripts\\Bayes1_lognormal.txt")
model.inits <- function(){list(sigma=2, beta0=1, beta1 = 1,beta2 = 1 )}
parameters = c("sigma", "beta2", "beta0", "beta1")
model.out <- bugs(model.data, model.inits,
model.file = "Bayes1_lognormal.txt",
parameters=parameters,
n.chains = 1, n.iter = 5000,  n.burnin = 1000, debug = T,
codaPkg=T,
working.directory = ".\\Scripts")
lognormal_bayes <- read.bugs(model.out)
summary(lognormal_bayes)
#parametric
library(survival)
survreg(Surv(value) ~ grubsize +  group, Grub, dist = "lognormal")$coefficients
# scale is sigma seems to be 1/the one from the baysian but beside this similar
#results between bayes and model are really similar
lognormal_results <- survreg(Surv(value) ~ grubsize +  group, Grub, dist = "lognormal")
# scale is sigma seems to be 1/the one from the baysian but beside this similar
#results between bayes and model are really similar
summary(lognormal_results)
model.function <- function(){
for (i in 1:N){
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]+ b0[id[i]]
#mu[i] <- beta1 *x1[i] + b0[id[i]]
}
#priors
sigma ~ dunif(0.1,100)
beta0 ~ dunif(-5,5)
beta1 ~ dunif(-5,5)
beta2 ~ dunif(-5,5)
for ( i in 1:Nsubj){
b0[i] ~ dnorm(0,0.1)
}
}
write.model(model.function, "Scripts\\Bayes1_lognormal_Random.txt")
model.inits <- function(){list(sigma=2, beta0=1, beta1 = 1,beta2 = 1, b0 = c(rep(1,times = 20)) )}
parameters = c("sigma", "beta2", "beta0", "beta1", "b0")
model.out <- bugs(model.data, model.inits,
model.file = "Bayes1_lognormal_Random.txt",
parameters=parameters,
n.chains = 2, n.iter = 5000,  n.burnin = 2000, debug = T,
codaPkg=T,
working.directory = ".\\Scripts")
Lognormal_bayes <- read.bugs(model.out)
#Bayes1_lognormal_random.r
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(coda)
library(R2OpenBUGS)
Grub <- read.csv("..\\data\\Grubs_Easy_normalized_size.csv")
model.data <- list( y = Grub$value, N = length(Grub$value), x1 = Grub$grubsize,
x2 = Grub$group, id = Grub$id, Nsubj = length(unique(Grub$id)))
model.function <- function(){
for (i in 1:N){
y[i] ~ dlnorm(mu[i], sigma)
mu[i] <- beta0 + beta1 *x1[i] + beta2 *x2[i]+ b0[id[i]]
#mu[i] <- beta1 *x1[i] + b0[id[i]]
}
#priors
sigma ~ dunif(0.1,100)
beta0 ~ dunif(-5,5)
beta1 ~ dunif(-5,5)
beta2 ~ dunif(-5,5)
for ( i in 1:Nsubj){
b0[i] ~ dnorm(0,0.1)
}
}
write.model(model.function, "Scripts\\Bayes1_lognormal_Random.txt")
model.inits <- function(){list(sigma=2, beta0=1, beta1 = 1,beta2 = 1, b0 = c(rep(1,times = 20)) )}
parameters = c("sigma", "beta2", "beta0", "beta1", "b0")
model.out <- bugs(model.data, model.inits,
model.file = "Bayes1_lognormal_Random.txt",
parameters=parameters,
n.chains = 2, n.iter = 5000,  n.burnin = 2000, debug = T,
codaPkg=T,
working.directory = ".\\Scripts")
Lognormal_bayes <- read.bugs(model.out)
summary(Lognormal_bayes)
# scale is sigma seems to be 1/the one from the baysian but beside this similar
#results between bayes and model are really similar
summary(lognormal_results)
model.out <- bugs(model.data, model.inits,
model.file = "Bayes1_lognormal_Random.txt",
parameters=parameters,
n.chains = 2,n.thin = 20, n.iter = 5000,  n.burnin = 2000, debug = T,
codaPkg=T,
working.directory = ".\\Scripts")
model.out <- bugs(model.data, model.inits,
model.file = "Bayes1_lognormal_Random.txt",
parameters=parameters,
n.chains = 2,n.thin = 100, n.iter = 5000,  n.burnin = 2000, debug = T,
codaPkg=T,
working.directory = ".\\Scripts")
Lognormal_bayes <- read.bugs(model.out)
summary(Lognormal_bayes)
#Bayes1_Weibull_random.r
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(coda)
library(R2OpenBUGS)
Grub <- read.csv("..\\data\\Grubs_Easy_normalized_size.csv")
model.data <- list( y = Grub$value, N = length(Grub$value), x1 = Grub$grubsize,
x2 = Grub$group, id = Grub$id, Nsubj = length(unique(Grub$id)))
# MODEL SPECIFICATION
model.function <- function(){
for (i in 1:N){
y[i] ~ dweib(k, invlambda[i])
log(invlambda[i]) <- beta0 + beta1 *x1[i] + beta2 *x2[i] + b0[id[i]]
}
#priors
k ~ dunif(0.1,100)
beta0 ~ dunif(-5,5)
beta1 ~ dunif(-5,5)
beta2 ~ dunif(-5,5)
for ( i in 1:Nsubj){
b0[i] ~ dnorm(0,0.1)
}
}
write.model(model.function, "Scripts\\Bayes1_Weibull_Random.txt")
model.inits <- function(){list(k=2, beta0=1, beta1 = 1,beta2 = 1, b0 = c(rep(1,times = 20)) )}
parameters = c("k", "beta2", "beta0", "beta1", "b0")
model.out <- bugs(model.data, model.inits,
model.file = "Bayes1_Weibull_Random.txt",
parameters=parameters,
n.chains = 2, n.iter = 5000,n.thin = 100,  n.burnin = 2000, debug = T,
codaPkg=T,
working.directory = ".\\Scripts")
Weibull_bayes <- read.bugs(model.out)
summary_weibull <- summary(Weibull_bayes)
b_params <- summary_weibull$statistics[grepl("b0\\[", dimnames(summary_weibull$statistics)[[1]]),]
mean(b_params[1:10,1])
attributes(summary_weibull$statistics)
Weibull_bayes <- read.bugs(model.out)
summary_weibull <- summary(Weibull_bayes)
b_params <- summary_weibull$statistics[grepl("b0\\[", dimnames(summary_weibull$statistics)[[1]]),]
mean(b_params[1:10,1])
attributes(summary_weibull$statistics)
summary_weibull
estimates
estimates <- survreg(Surv(value) ~ grubsize +  group, Grub, dist = "weibull")
estimates
